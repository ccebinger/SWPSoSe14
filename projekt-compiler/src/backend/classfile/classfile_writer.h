/*[--**--]
 * Copyright (C) 2014  SWPSoSe14Cpp Group
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this
 * program; if not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This header declares the functions for @see classfile_writer.cc.
 * The @see classfile_writer writes the specific classfile we want to create from a rail program.
 * For each function in an rail program (incl. main), we need to produce a method in this classfile.
 * To ensure a clean initialization we need to use the two methods <init> and <clinit>.
 * In addition each classfile contains the executable main function because alle Rail programms must have
 * one.
 *
 */

#ifndef CLASSFILE_WRITER_H_
#define CLASSFILE_WRITER_H_

#include <array>
#include <iostream>
#include <map>
#include <memory>
#include <vector>
#include <frontend/Graphs.h>
#include <backend/codegen/Bytecode.h>
#include <backend/classfile/constant_pool.h>

/**
 * This class is the result of the compiling pipeline.
 * It represents the class-file containing Java bytecode that can be
 * hand over to the JVM.
 * The generated bytecode is fully valid.
 * Primarily we use the Java v.7 but it is possible to extend the number
 * of versions.
 */
class ClassfileWriter {
 public:
  /**
   * This enum contains the Java version number that is written in the
   * class file.
   */
  enum ClassfileVersion {
    /**
     * Java version 7 is the default version we use.
     */
    JAVA_7
  };

  /**
   * The constructor of the classfile_writer.
   *
   * @param version             The Java version.
   * @param constant pool       The current constant pool of the classfile.
   * @param graphs              The graph we extract the rail commands from.
   * @param codeFunctions       The mapping of the function and appropriate bytecode.
   * @param out                 The stream we write on.
   */
  ClassfileWriter(ClassfileVersion version, ConstantPool* constantPool,
                    Graphs& graphs,
                    const std::map<std::string, codegen::Bytecode&> codeFunctions,
                    std::ostream* out);
  /**
   * The constructor of the classfile_writer.
   *
   * @param version             The Java version.
   * @param constant pool       The current constant pool of the classfile.
   * @param graphs              The graph we extract the rail commands from.
   * @param codeFunctions       The mapping of the function and appropriate bytecode.
   * @param out                 The stream we write on.
   * @param count               The inner_classes count
   */
  ClassfileWriter(ClassfileVersion version, ConstantPool* constantPool,
                    Graphs& graphs,
                    const std::map<std::string, codegen::Bytecode&> codeFunctions,
                    std::ostream* out, uint16_t inner_classes);

  /**
   * The deconstructor of the classfile_writer
   */
  virtual ~ClassfileWriter();

  /**
   * This method writes indeed the classfile with the help of several internal methods.
   * It uses the the outstream @see out to write on.
   *
   * @return void
   */
  void WriteClassfile();
  static const std::string inner_classes_attr;
 protected:
  uint16_t inner_classes_count;
  static const unsigned char inner_class_flag[];
  static const unsigned char kPublicSuperAccessFlag[];

  /**
   * An instance of the graph given by the frontend.
   */
  Graphs graphs_;

  /**
   * An instance of a @see bytecode_writer.
   */
  Bytecode_writer writer;

  /**
   * The magic number indicates that our generated file is
   * a valid classfile.
   */
  static const char kMagicNumber[];

  /**
   * Maps the Java version number to the appropriate classfile
   * version number with 4 bytes.
   */
  static std::map<ClassfileVersion, std::array<char, 4>> kVersionNumbers;

  /**
   * The ourstream we write our classfile on.
   */
  std::ostream *out_;

  /**
   * The version number of the classfile.
   */
  ClassfileVersion version_;

  /**
   * The current constant pool of the classfile.
   * It is a shared pointer thus all participants work with the same
   * constant pool.
   */
  std::shared_ptr<ConstantPool> constant_pool_;

  /**
   * Maps a function name to its appropriate bytecode.
   */
  const std::map<std::string, codegen::Bytecode&> code_functions_;

  /**
   * This constant is used to write elements we do not use within the classfile.
   * Should be initialized with 4 bytes with value 0 (i.e. 0x0000).
   * It might become obsolet withe further development.
   */
  static const char kNotRequired[];

  /**
   * This constant is used to write a public access flag.
   */
  static const char kPublicAccessFlag[];

  /**
   * This constant is used to write a public static access flag.
   */
  static const char kPublicStaticAccessFlag[];

  /**
   * This constant is used to write maximum stack depth.
   * It is used in the code attribute.
   */
  static const uint16_t kMaxStack;

  /**
   * Method to write the magic number of the classfile.
   * (i.e. 0xCAFEBABE)
   *
   * @return void
   */
  virtual void WriteMagicNumber();

  /**
   * Method to write the version number appropriate to @see version_
   *
   * @return void
   */
  virtual void WriteVersionNumber();

  /**
   * Method to write the constant pool that was generated in @see constant_pool.cc
   *
   * @return void
   */
  virtual void WriteConstantPool();

  /**
   * Method to write the access flag of the classfile.
   *
   * @return void
   */
  virtual void WriteAccessFlags();

  /**
   * Method to write the name of the classfile.
   *
   * @return void
   */
  virtual void WriteClassName();

  /**
   * Method to write the super class names. At the moment we just refer to
   * java.lang.Object.
   *
   * @return void
   */
  virtual void WriteSuperClassName();

  /**
   * Method to write the used interfaces.
   * Because Rail does not uses interfaces we don't use them either
   *
   * @return void
   */
  virtual void WriteInterfaces();

  /**
   * Method to write the fields in the classfile.
   *
   * @return void
   */
  virtual void WriteFields();

  /**
   * Method to write methods in the classfile.
   * The methode code is generated in the class @see Bytecode.cpp
   *
   * @return void
   */
  virtual void WriteMethods();

  /**
   * Method to write the <init> method in the classfile.
   * For us it is always the same bytecode.
   *
   * @return void
   */
  virtual void WriteInitMethod();

  /**
   * Method to write the <clinit> method in the classfile.
   * For us it is always the same bytecode
   *
   * @return void
   */
  virtual void WriteClInitMethod();

  /**
   * Method to write the attributes in the classfile, particularly the code attribute.
   *
   * @return void
   */
  virtual void WriteAttributes(const std::string &key);

  size_t get_class_ref(const std::string& _class);
};
#endif /* CLASSFILE_WRITER_H_ */
